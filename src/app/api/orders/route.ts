import { NextRequest, NextResponse } from 'next/server';
import { connectDB } from '@/utils/db';
import Order from '@/models/Order';
import mongoose from 'mongoose';

// Add interface for order item structure
interface OrderItem {
  _id: string;
  productId?: string;
  productType: string;
  title: string;
  image: string;
  price: number;
  quantity: number;
  size?: number;
  metalOption?: {
    karat: string;
    color: string;
  };
  customization?: {
    isCustomized: boolean;
    customizationType: 'setting-diamond' | 'setting-gemstone' | 'preset';
    customizationDetails?: {
      stone?: {
        type: string;
        carat: number;
        color: string;
        clarity: string;
        gemstoneType?: string;
        image?: string;
      };
      setting?: {
        style: string;
        metalType: string;
        settingType: string;
      };
    };
  };
}

export async function POST(request: NextRequest) {
  try {
    await connectDB();

    const orderData = await request.json();
    console.log('üìù Creating order with data:', {
      customerEmail: orderData.customerEmail,
      paymentIntentId: orderData.paymentInfo?.stripePaymentIntentId,
      total: orderData.pricing?.total
    });

    // Basic validation for required order data
    const requiredFields = ['items', 'shippingAddress', 'paymentInfo', 'pricing'];
    for (const field of requiredFields) {
      if (!orderData[field]) {
        return NextResponse.json(
          { error: `Missing required field: ${field}` },
          { status: 400 }
        );
      }
    }

    // Ensure customization details are properly structured
    orderData.items = orderData.items.map((item: OrderItem) => {
      if (item.customization?.customizationDetails?.stone) {
        return {
          ...item,
          customization: {
            ...item.customization,
            customizationDetails: {
              ...item.customization.customizationDetails,
              stone: {
                type: item.customization.customizationDetails.stone.type,
                carat: Number(item.customization.customizationDetails.stone.carat),
                color: item.customization.customizationDetails.stone.color,
                clarity: item.customization.customizationDetails.stone.clarity,
                gemstoneType: item.customization.customizationDetails.stone.gemstoneType,
                image: item.customization.customizationDetails.stone.image
              }
            }
          }
        };
      }
      return item;
    });

    // Create order - DON'T set orderNumber manually, let the pre-save hook handle it
    const order = new Order({
      ...orderData,
      status: 'pending',
      paymentStatus: 'pending'
      // orderNumber will be generated by the pre-save hook
    });

    console.log('üíæ Saving order...');
    const savedOrder = await order.save();

    // Reduce stock
    for (const item of savedOrder.items) {
      const productModel = mongoose.model(item.productType);
      await productModel.findByIdAndUpdate(item.productId, { $inc: { totalPieces: -item.quantity } });
    }
    
    console.log('‚úÖ Order created successfully:', {
      id: savedOrder._id,
      orderNumber: savedOrder.orderNumber,
      paymentIntentId: savedOrder.paymentInfo?.stripePaymentIntentId
    });

    return NextResponse.json({
      success: true,
      order: {
        _id: savedOrder._id,
        orderNumber: savedOrder.orderNumber,
        status: savedOrder.status,
        paymentStatus: savedOrder.paymentStatus,
        total: savedOrder.pricing.total,
        estimatedDelivery: savedOrder.estimatedDelivery
      },
      orderNumber: savedOrder.orderNumber
    }, { status: 201 });

  } catch (error) {
    console.error('‚ùå Error creating order:', error);
    
    // More detailed error logging
    if (error instanceof Error) {
      console.error('Error message:', error.message);
      console.error('Error stack:', error.stack);
    }
    
    return NextResponse.json(
      { 
        error: 'Failed to create order', 
        details: error instanceof Error ? error.message : 'Unknown error' 
      },
      { status: 500 }
    );
  }
}

export async function GET(request: NextRequest) {
  try {
    await connectDB();
    const { searchParams } = new URL(request.url);
    const email = searchParams.get('email');
    const orderNumber = searchParams.get('orderNumber');

    let query = {};
    if (email) {
      query = { customerEmail: email };
    } else if (orderNumber && orderNumber !== 'undefined') {
      query = { orderNumber };
    }

    console.log('üîç Searching for orders with query:', query);

    const orders = await Order.find(query)
      .sort({ createdAt: -1 })
      .limit(50);

    console.log('üìã Found orders:', orders.length);

    return NextResponse.json({ orders });

  } catch (error) {
    console.error('Error fetching orders:', error);
    return NextResponse.json(
      { error: 'Failed to fetch orders' },
      { status: 500 }
    );
  }
}